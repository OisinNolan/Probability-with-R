---
title: "TP Probabilités"
author: "Piotr Frątczak"
date: "6 05 2020"
output: html_document
---

```{r setup, include=FALSE}

source("generateurs.R")

graine <- 9274629
set.seed(graine)
```

## Question 2.1

```{r, echo=TRUE}
k <- 1000

Standard_Minimal <- StandardMinimal(k=k, graine=graine)
RANDU <- randu(k=k, graine=graine)
Von_Neumann <- VonNeumann(n=k, graine=graine)
Mersenne_Twister <- MersenneTwister(n=k, graine=graine)

par(mfrow=c(2,2)) 
hist(Standard_Minimal)
hist(RANDU)
hist(Von_Neumann)
hist(Mersenne_Twister)
```

## Question 2.2

```{r, echo=TRUE}

par(mfrow=c(2,2)) 
plot(Standard_Minimal[1:(k-1)], Standard_Minimal[2:k])
plot(RANDU[1:(k-1)], RANDU[2:k])
plot(Von_Neumann[1:(k-1)], Von_Neumann[2:k])
plot(Mersenne_Twister[1:(k-1)], Mersenne_Twister[2:k])

```


Il n'y a pas de modèle apparent qui relit les valeurs $S_{n-1}$ et $S_n$.
Comme prévu, les valeurs semble d'être générées d'une façon aléatoire.


## Question 3

```{r, echo=FALSE}

Frequency <- function(x, nb)
{
  s <- 0
  totalN <- 0
  
  for (i in x){
    bin <- rev(binary(i))
    totalN <- totalN + nb
    
    for (n in 1:nb) {
      if (bin[n] == 1) s <- s+1
      else             s <- s-1
    }
  }
  
  s_obs <- abs(s) / sqrt(totalN)
  Pvaleur = 2 * (1 - pnorm(s_obs))
  
  return(Pvaleur)
}
```

```{r, echo=TRUE}
# Generating a vector of 100 random numbers in [0,10000]
seeds <- sample.int(10000, 100)

# Try some of our algorithms on each of the 100 seeds,
# get the average P value for each.
RANDUavgPvalue <- 0
for(i in 1:length(seeds)) {
  # La plage des valeurs de randu: {0, ..., 2^31-1}
  # 2^31-1 s'écrit sur 31 bits
  RANDUavgPvalue <- RANDUavgPvalue + Frequency(randu(1000, seeds[i]), 31)
}
RANDUavgPvalue <- RANDUavgPvalue / 100

SMavgPvalue <- 0
for(i in 1:length(seeds)) {
  # La plage des valeurs de Standard Minimal: {0, ..., 2^31-2}
  # 2^31-1 s'écrit sur 31 bits
  SMavgPvalue <- SMavgPvalue + Frequency(StandardMinimal(1000, seeds[i]), 31)
}
SMavgPvalue <- SMavgPvalue / 100

MTavgPvalue <- 0
for(i in 1:length(seeds)) {
  # La plage des valeurs de Mersenne-Twister: {0, ..., 2^32-1}
  # 2^32-1 s'écrit sur 32 bits
  MTavgPvalue <- MTavgPvalue + Frequency(MersenneTwister(1000, 1, seeds[i]), 32)
}
MTavgPvalue <- MTavgPvalue / 100

VNavgPvalue <- 0
for(i in 1:length(seeds)) {
  # La plage des valeurs de Von Neumann: {0, ..., 9999}
  # 9999 s'écrit sur 14 bits
  VNavgPvalue <- VNavgPvalue + Frequency(VonNeumann(1000, 1, seeds[i]), 14)
}
VNavgPvalue <- VNavgPvalue / 100
```

Algorithm        | Avg. P value
---------------- | ----------------
RANDU            | `r RANDUavgPvalue`
Standard Minimal | `r SMavgPvalue`
Mersenne-Twister | `r MTavgPvalue`
Von Neumann      | `r VNavgPvalue`

