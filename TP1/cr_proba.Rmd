---
title: "TP Probabilités"
author: "Piotr Frątczak, Aydın Akaydın, Oisín Nolan"
date: "06.05.2020"
output: html_document
---

```{r setup, include=FALSE}

source("generateurs.R")
source("tests.R")
source("files.R")

library(randtoolbox)

graine <- 9274629
set.seed(graine)
```

# 1 Tests de générateurs pseudo-aléatoires


## Question 2.1
#### Test Visuel

```{r, echo=TRUE}
k <- 1000

RANDU            <- randu(k=k, graine=graine)
Standard_Minimal <- StandardMinimal(k=k, graine=graine)
Mersenne_Twister <- MersenneTwister(n=k, graine=graine)
Von_Neumann      <- VonNeumann(n=k, graine=graine)

```
```{r, echo=FALSE}

par(mfrow=c(2,2)) 
hist(RANDU,            xlab='Nombre généré', ylab='Fréquence', main='RANDU')
hist(Standard_Minimal, xlab='Nombre généré', ylab='Fréquence', main='Standard Minimal')
hist(Mersenne_Twister, xlab='Nombre généré', ylab='Fréquence', main='Mersenne-Twister')
hist(Von_Neumann,      xlab='Nombre généré', ylab='Fréquence', main='Von Neumann')
```

## Question 2.2
#### Test Visuel
```{r, echo=FALSE}

par(mfrow=c(2,2)) 
plot(RANDU[1:(k-1)],            RANDU[2:k],            xlab='S précédent', ylab='S', main='RANDU')
plot(Standard_Minimal[1:(k-1)], Standard_Minimal[2:k], xlab='S précédent', ylab='S', main='Standard Minimal')
plot(Mersenne_Twister[1:(k-1)], Mersenne_Twister[2:k], xlab='S précédent', ylab='S', main='Mersenne-Twister')
plot(Von_Neumann[1:(k-1)],      Von_Neumann[2:k],      xlab='S précédent', ylab='S', main='Von Neumann')
```


Il n'y a pas de modèle apparent qui relit les valeurs $S_{n-1}$ et $S_n$.
Comme prévu, les valeurs semble d'être générées d'une façon aléatoire.


## Question 3
#### Test de fréquence monobit


```{r, echo=FALSE}

# Try some of our algorithms on each of the 100 seeds,
# get the average P value for each.
RANDUfreq <- RunFrequencyTest(randu, 100, 31)
SMfreq    <- RunFrequencyTest(StandardMinimal, 100, 31)
MTfreq    <- RunFrequencyTest(MersenneTwister, 100, 32)
VNfreq    <- RunFrequencyTest(VonNeumann, 100, 14)

```

Règle de décision à $1\%$ : Au vu du principe décrit ci-dessus, plus la Pvaleur est petite plus on peut rejeter de manière sûre le fait que le séquence est aléatoire. En pratique, si la Pvaleur calculée est inférieure à $0.01$ alors la séquence n’est pas aléatoire. Sinon, on ne peut pas conclure pour autant qu’elle l’est, mais rien n’inﬁrme cette hypothèse, au sens de ce test. Il est recommandé que chaque séquence testée fasse au minimum $100$ bits (i.e. $n ≥ 100$) aﬁn que l’application du théorème de la limite centrale ait un sens.

Algorithme               | P-valeur moyenne         | Taux de réussite
------------------------ | ------------------------ | ------------------------
RANDU                    | `r RANDUfreq$avgPvalue`  | `r RANDUfreq$passRate`
Standard Minimal         | `r SMfreq$avgPvalue`     | `r SMfreq$passRate`
Mersenne-Twister         | `r MTfreq$avgPvalue`     | `r MTfreq$passRate`
Von Neumann              | `r VNfreq$avgPvalue`     | `r VNfreq$passRate`


## Question 4
#### Test des runs

```{r, echo=FALSE}

RANDUruns <- RunRunsTest(randu, 100, 31)
SMruns    <- RunRunsTest(StandardMinimal, 100, 31)
MTruns    <- RunRunsTest(MersenneTwister, 100, 32)
VNruns    <- RunRunsTest(VonNeumann, 100, 14)
```

Règle de décision à $1\%$ : Si la Pvaleur calculée est inférieure à $0.01$, alors on peut conclure que la séquence n’est pas aléatoire.

Algorithme               | P-valeur moyenne         | Taux de réussite
------------------------ | ------------------------ | ------------------------
RANDU                    | `r RANDUruns$avgPvalue`  | `r RANDUruns$passRate`
Standard Minimal         | `r SMruns$avgPvalue`     | `r SMruns$passRate`
Mersenne-Twister         | `r MTruns$avgPvalue`     | `r MTruns$passRate`
Von Neumann              | `r VNruns$avgPvalue`     | `r VNruns$passRate`

## Question 5
#### Test d’ordre

```{r, echo=FALSE}

RANDUord <- RunOrderTest(randu, 100)
SMord    <- RunOrderTest(StandardMinimal, 100)
MTord    <- RunOrderTest(MersenneTwister, 100)
VNord    <- RunOrderTest(VonNeumann, 100)
```

Règle de décision à $1\%$ : L’hypothèse que les observations de u sont issues d’une loi uniforme (discrète ou uniforme) est rejetée si la Pvaleur est inférieure à $1\%$. 
 
Algorithme              | P-valeur moyenne        | Taux de réussite
----------------------- | ----------------------- | -----------------------
RANDU                   | `r RANDUord$avgPvalue`  | `r RANDUord$passRate`
Standard Minimal        | `r SMord$avgPvalue`     | `r SMord$passRate`
Mersenne-Twister        | `r MTord$avgPvalue`     | `r MTord$passRate`
Von Neumann             | `r VNord$avgPvalue`     | `r VNord$passRate`

Taux de réussite est le pourcentage de tests où la régle de décision à $1\%$ a été satisfaite.

Selon les tests, l'algorithme de Von Neumann est de la pire qualité parmi les quatre générateurs. Puis, on a RANDU, qui a passé les deux premiers tests seulement environ $34\%$ de fois. Standard Minimal a passé presque tous les tests et Mersenne-Twister a été le meilleur.

# 3 Application aux files d’attentes

## Question 7

```{r, echo=TRUE}
file08 <- FileMM1(8, 15, 12)
file14 <- FileMM1(14, 15, 12)
file15 <- FileMM1(15, 15, 12)
file20 <- FileMM1(20, 15, 12)
```
```{r, echo=FALSE}

evo08 <- evolutionFile(file08$arrivee, file08$depart)
evo14 <- evolutionFile(file14$arrivee, file14$depart)
evo15 <- evolutionFile(file15$arrivee, file15$depart)
evo20 <- evolutionFile(file20$arrivee, file20$depart)

par(mfrow=c(2,2))
plot(evo08$T, evo08$N , type='s', xlab='Temps [h]', ylab='Nombre de personnes dans la file', main= '8 nouveaux clients par heure')
plot(evo14$T, evo14$N , type='s', xlab='Temps [h]', ylab='Nombre de personnes dans la file', main='14 nouveaux clients par heure')
plot(evo15$T, evo15$N , type='s', xlab='Temps [h]', ylab='Nombre de personnes dans la file', main='15 nouveaux clients par heure')
plot(evo20$T, evo20$N , type='s', xlab='Temps [h]', ylab='Nombre de personnes dans la file', main='20 nouveaux clients par heure')
```

Sur la première visualisation 8 personnes viennent par heure en moyen et 15 personnes partent donc tout le monde est servi vite et la file est souvent vide. Dans la situation à droite, la longueur de la file oscile autour de la même valeur. Si le taux de personnes venantes et partentes sont les mêmes (15 personnes par heure), la file est parfois vide, parfois remplie, elle est sous contrôle. Quand plus de gens viennent que sortent, la file est remplie et le serveur n'arrive pas à la racourcir.

## Question 8

```{r, echo=TRUE}
SM08 <- StatsMoyens(file08$arrivee, file08$depart,  8, 15)
SM14 <- StatsMoyens(file14$arrivee, file14$depart, 14, 15)
```

$\lambda$               | $\mathbb{E}(W)$ estimé  | $\mathbb{E}(N)$         | $\lambda\mathbb{E}(W)$ estimé
----------------------- | ----------------------- | ----------------------- | -----------------------
8                       | `r SM08$EW`             | `r SM08$EN`             | `r 8*SM08$EW`
14                      | `r SM14$EW`             | `r SM14$EN`             | `r 14*SM14$EW`

Les résulatats estimés de  $\lambda\mathbb{E}(W)$ sont proches des valeurs attendus de la formule de Little $\mathbb{E}(N) = \lambda\mathbb{E}(W)$.

On a simulé des files avec de plus grandes valeurs de $D$ afin d'approcher la vraie valeur de $W$. On a déduit que quand la valeur de $D$ augmente, l'espérence de $W$ multipliée par $\lambda$ approche espérence de $N$.